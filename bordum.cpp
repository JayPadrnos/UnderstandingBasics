// Get an SFML

//I need a 2D visual space
//user needs to be able to move and interact with other objects in the room
//there needs to be multiple rooms
//there needs to be doors in between certain rooms where keys are needed 
//there needs to be items for the player and inventory


//needs enemies 
//needs boss type 
//enemies need inventory with % to drop items they equipped 
//stats and skills menu
//different attacks for weapons
//skills for player to have moves that are not dependent on weapons but do different things with dif weapons
// different classes of characters or rather skill paths they can go down
// cosmetic for character to change color shirt pants hair and eyes
// name character and have save files for the characters
// have an mp3 playing for backround music and an adjust volume meter
// have animation for character using key items or levers or buttons
// have an end screen animation then credits when beating the final boss with a continue play and respawn player at spawn and reset the world while increasing difficulty
// create easter eggs inside of the maps so that players can uncover hidden items 


// DirectX for API allow for Proton through steam allowing for Linux to run the game.
// Get an SMFL like MonoGame which is in C# and Love2D which is in Lua Roblox type these are both for 2D
// Efficient rendering collision detection and game logic optimize critical parts of engine
// SDL_mixer or OpenAL for Audio
// Design input handing for keyboard mouse and controller
// Debugging tools
// Cross platform libraries


// Develop Graphics Engine that can render 2D or 3D 
// Optimize

// Physics Engine handle collision detection and phyusics simulation especially if complex physics interactions

// If world is proceedurally generated algorithms and systems for world gen (terrain biomes etc)

// Game Logic rules logic mechanisms character behavior item systems and progression

// Audio Engine handles music SFX and spatial audio

// Networking for multiplayer and local play along with a LAN system

// Test test test debug

// Optimize performance memory usage and responsiveness

// Document and engage in community along with if published prepare for distribution on various platforms





///// Visualizer with audio
////// Push the button Game


//Geometry Learn 3D gemoetry, which includes understanding vertices edges and faces 
//Coordinate Systems Understand the different coordinate systems, such as world space, object space, camera space and screen space, these are essentially for placing rendering objects in 3d
//Transformations Study transformations like translation rotation and scaling
//Projection Learn about projection both orthograpphic and perspective projection matrices are crucial for mapping 3d objects onto a 2d screen
//Shading and lighting understand the basics of shading and lighting models. simple models like Lambertian reflection are a good starting point
//Matrices Familiarize yourself with matrix operations which are used extensively in 3d graphics for transformations and projections
//Rasterization the process of converting 3d objects into 2D pixels on the screen 
//Z-Buffering Understand z-buffering for handling depth information adetermining which objects are visible in the scene
//Rendering pipline study the graghics renderring pipleine including vertex processing geometry proccessing pixel processing and the stages of a graphics API like DirectX or OpenGL
//Shaders get acquainted with shaders which are programs useed to control the rendering of 3d objects youll typically need to write vertex and fragment pixel shaders
//User Input learn how to handle user input as youll want tto control the position adn orientation of your 3d objects interactively
//Mathematics refresh your knowledge of linear algebra trigonometry and vector mathematics these are fundamentals to understanding 3d graphics


//tabletop sim with 3d rendered 4 chairs to start look to add war table type





///    Ked project
//Javascript to C++ wrapper and C++ to javascript wrapper
////


// API's < Framework > GUI > Graphics and Rendering code
// Must work with OS API's 
// User friendly 
// Ability to overcome and adapt to updates of other OS API's

// API
// Define it; the functionality of a graphics API. Consider what graphic primitives, (e.g. lines triangles quads); rendering techniques you want to implement 
// Understand the graphics hardware on the platforms available, study GPU architectures, shader languages, and the graphics pipeline.
// Core rendering engine implement functions for rendering primitives, setting up buffers, and managing the rendering pipeline.
// Design and implement a shading language for specifying how objects are shaded and lit **Critical Component** of a graphics API
// Implement data structures and algorithms for managing geometry data such as vertices, triangles, and textures.
// Math Library Develop a math library to handle transformations, vectors, matrices, and other mathmatical operations used in graphics
// Minimize data transfer between cpu and gpu, culling techniques
// Render techniques such as shadow mapping post processing effects and anti-ailasing, depending on the capabilities you want to offer
// Create a system for managing windows and graphics contexts on different platforms This may involve interacting with platform specif windowing API's
// Cross platform consider porting it to different OS's and graphic hardware
// Document to help devs understand and use your API
// Test and debug till it is ironed out
// Build a community around the API offering support and resources for devs
// Build an ecosystem for the API including dev tools and asset pipelines and third party plugins
// Decide on the licensing terms and distribution method for your API
//  Be prepped for updates and mantenance for the API as new hardware and software dev arise



// Shader Language




// Core Rendering engine

